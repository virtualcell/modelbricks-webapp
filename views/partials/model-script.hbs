//script for graphics

//defining string rgb values by hashing them
Object.defineProperty(String.prototype, 'rgb', {
  //hashing string
  value: function() {
    var hash = 0, i, chr;
    for (var i = 0; i < this.length; i++) {
      chr   = this.charCodeAt(i);
      hash = (chr << (6 * i)) + hash;
      hash |= 0; // Convert to 32bit integer
    }
    //changing hash into rgb format:
    if (hash < 0) {
      hash *= -1;
    }
    if (hash < 65280) {
      hash++;
      hash *= 17777777;
    }
    //16777215 is 255 in base 10
    while (hash > 16777215) {
      hash = hash / 16;
    }
    color = Math.floor(hash);
    color = color.toString(16);
    var rgb = [];
    for (var i = 0; i < 3; i++) {
      rgb.push(parseInt(color.slice(i, 2 + i), 16));
    }
    //correcting colors too dark
    if (rgb.reduce((a, b) => a + b, 0) < 600) {
      const buff = 255 - Math.max(rgb[0], rgb[1], rgb[2]);
      for (var i = 0; i < 3; i++) {
        rgb[i] = rgb[i] + buff;
      }
      color = '';
      for (var i = 0; i < 3; i++) {
        color += rgb[i].toString(16);
      }
    }
    return (color);
  }
});

//splits string at target character;
function splitString(string, target) {
  list = [];
  lastTagert = 0;
  for (var i = 0; i < string.length; i++) {
    if (string[i] == target) {
      list.push(string.slice(lastTagert, i));
      lastTagert = i + 1;
    }
  }
  list.push(string.slice(lastTagert, string.length));
  return(list);
}


//simple class to hold data from molecule's sites
class Site {
  constructor(name, states) {
    this.bondName = null;
    for (var i = 0; i < states.length; i++) {
      if (states[i].includes('!')) {
        var pair = splitString(states[i], '!');
        states[i] = pair[0];
        this.bondName = parseInt(pair[1]);
      }
    }
    if (name.includes('!')) {
      var pair = splitString(name, '!');
      name = pair[0];
      this.bondName = parseInt(pair[1]);
    }
    this.name = name;
    this.states = states; //list of state names
    this.stateObjects = Object();
    this.position = null; //x y coords of where to draw bond
  }
}


//class for molecules
//to do for graphics:
//fix canvas dims for states
//make each tags readable
//seperate script from html to increase readability
//can we parse vcmls using only one run?
class Molecule {
  constructor(def) {
    //bionetgen definition
    this.def = def;
    //6 digit rgb hex
    this.color = '';
    //name of molecule
    this.name = '';
    //this.sites is an object, keys: site names, values: list of state names
    //this.sites, list of Site() instances
    this.process();
    //colors used to draw states
    this.stateColors = ['#FBC6D0', '#00FDFF', '#FA26A0', '#99F3BD'];
    //object, keys: bond names, values: x,y pair of pt to draw bond
    this.bonds = new Object();
  }

  //initialize this.color, sites, name from bionetgen def
  process() {
    //notice bond info is kept in this.sites and removed later
    var temp = splitString(this.def, '(');
    this.name = temp[0];
    this.color = this.name.rgb();
    var sites = temp[1].slice(0, -1);
    //sites = sites.slice(sites.length - 2);
    sites = splitString(sites, ',');
    var siteList = [];
    var temp = '';
    for (var i = 0; i < sites.length; i++) {
      if (sites[i].includes(')')) {
        sites[i] = sites[i].replace(')', '');
      }
      if (sites[i].includes('~')) {
        //if sites have states
        temp = splitString(sites[i], '~');
        var states = temp.slice(1);
        siteList.push(new Site(temp[0], states));
      } else if (sites[i].length != 0) {
        //if there are sites but no states
        siteList.push(new Site(sites[i], []));
      } else {
        //if there are no sites
        siteList = null;
      }
    }
    if (siteList == null) {
      this.sites = [];
    } else {
      this.sites = siteList;
    }
  }

  //draw rounded rect
  drawRoundRect(canvasID, x, y, radius, length, rgb) {
    var canvas = document.getElementById(canvasID);
    var ctx = canvas.getContext('2d');
    ctx.fillStyle = '#' + rgb;
    ctx.beginPath();
    ctx.arc(x + radius, y + radius, radius, Math.PI / 2, Math.PI * (3/2));
    ctx.arc(x + radius + length, y + radius, radius, Math.PI * (3/2), Math.PI / 2);
    ctx.lineTo(x + radius, y + 2 * radius);
    ctx.fill();
    ctx.fillStyle = '#000000';
    ctx.stroke();
    ctx.closePath();
  }

  //draw bionetgen sites with states labeled
  drawSitesComplex(canvasID, x, y, radius) {
    var canvas = document.getElementById(canvasID);
    var ctx = canvas.getContext('2d');
    const siteRadius = 8;
    var siteLength = 0;
    var stateLength = 0;
    var longestState = 0;
    var tallestState = 0;
    var keys = [];
    var hasStates = false;
    for (var i = 0; i < this.sites.length; i++) {
      keys.push(this.sites[i].name);
    }
    //adding sites
    var siteNames = [];
    for (var i = 0; i < keys.length; i++) {
      siteNames.push(keys[i]);
    }
    var dx = radius - 2 * siteRadius;
    for (var i = 0; i < keys.length; i++) {
      //bottom line of sites
      var dy = 2 * radius + 2;
      dx = dx + 2 * siteRadius + siteLength;
      if (longestState > 2 * siteRadius + siteLength) {
        dx = dx - siteLength + longestState - 2 * siteRadius;
      }
      //drawing sites
      siteLength = 4.9 * siteNames[i].length;
      this.drawRoundRect(canvasID, x + dx - radius / 2, y + dy - radius / 2, siteRadius, siteLength, siteNames[i].rgb());
      //drawing site names
      ctx.fillStyle = '#000000';
      ctx.font = "12px Arial";
      ctx.fillText(siteNames[i], x + dx - siteRadius / 2, y + dy + siteRadius / 2 + 1);
      //drawing states of sites
      var states = this.sites[i].states;
      if (states.length == 0) {
        longestState = 0;
      } else if (!hasStates) {
        hasStates = true;
      }
      //add bonds to stateless sites
      if (this.sites[i].bondName != null) {
        if (this.sites[i].states.length == 0) {
          this.sites[i].position = [x + dx, y + dy + siteRadius];
        }
      }
      for (var u = 0; u < states.length; u++) {
        var sx = x + dx - siteRadius + 2;
        var sy = y + dy + u * 13 + siteRadius;
        //fix lengths
        stateLength = this.sites[i].states[u].length * 9;
        if (this.sites[i].states[u].length <= 10) {
          stateLength += 3;
        }
        if (longestState < stateLength) {longestState = stateLength;}
        //add bonds to sites with states
        if (this.sites[i].bondName != null) {
          this.sites[i].position = [sx + stateLength / 2, sy + 13];
        }
        //draw states
        var colorIndex = u;
        if (colorIndex > 3) {colorIndex = colorIndex % 3;}
        ctx.fillStyle = this.stateColors[colorIndex];
        ctx.beginPath();
        ctx.rect(sx, sy, stateLength, 13);
        if (sy + 13 > tallestState) {
          tallestState = sy + 13;
        }
        ctx.fill();
        ctx.fillStyle = '#000000';
        ctx.stroke();
        ctx.closePath();
        //naming states
        ctx.fillStyle = '#000000';
        ctx.fillText(this.sites[i].states[u], sx + 1.5, sy + 10.5);
      }
    }
    //return total [length, height] to compare to default dimensions
    var dims = []
    //use either end of site, state, or molecule for x component
    var possibleLengths = [x + dx - radius / 2 + siteLength, dx, sx + stateLength];
    for (var i = 0; i < 3; i++) {
      if (isNaN(possibleLengths[i])) {
        possibleLengths[i] = 0;
      }
    }
    dims.push(possibleLengths.reduce(function (a, b) {
      return (Math.max(a, b));
    }));
    if (hasStates) {
      dims.push(tallestState);
    } else {
      dims.push(radius * 2 + siteRadius + 2);
    }
    return (dims);
  }

  //draw molecule with states and sites labled
  drawComplex(canvasID, x, y) {
    var canvas = document.getElementById(canvasID);
    var ctx = canvas.getContext('2d');
    const radius = 15;
    var length = 8 * this.name.length - radius / 2;
    if (length < 0) {length *= -1;}
    //notice drawSitesComplex() is called twice
    //this is a bad implementation but it doesn't effect runtime noticably
    var dims = this.drawSitesComplex(canvasID, x, y, radius);
    if (length < dims[0]) {
      length = dims[0] - x;
    }
    //drawing pill shape
    this.drawRoundRect(canvasID, x, y, radius, length, this.color);
    //drawing sites
    this.drawSitesComplex(canvasID, x, y, radius);
    //drawing name
    ctx.fillStyle = '#000000';
    ctx.font = "15px Arial";
    ctx.fillText(this.name, x + radius / 2, y + radius + 5);
    //return [length, height] of molecule for Graphic class
    return ([radius * 2 + length, dims[1]]);
  }
}


//each bionetgen should have own Graphic instance
class Graphic {
  constructor(def) {
    //bionetgen definition
    this.def = def;
    //list of instances of molecule classes
    this.molecules = [];
    //initializing this.molecules
    this.process();
  }

  process() {
    var defs = splitString(this.def, '.');
    for (var i = 0; i < defs.length; i++) {
      this.molecules.push(new Molecule(defs[i]));
    }
  }

  //only works for species with two molecules or less, fix this
  draw(canvasID, x, y) {
    var length = 0;
    var height = 0;
    var names = new Set();
    var pairs = [];//list of pairs of xy coords for each bond
    //drawing the graphics on the canvas
    var canvas = document.getElementById(canvasID);
    if (canvas.getContext) {
      var ctx = canvas.getContext('2d');
      //extracting bonds
      for (var i = 0; i < this.molecules.length; i++) {
        var dims = this.molecules[i].drawComplex(canvasID, 2 + length, 2);
        length += dims[0];
        if (dims[1] > height) {
          height = dims[1];
        }
      }
      for (var i = 0; i < this.molecules.length; i++) {
        for (var y = 0; y < this.molecules[i].sites.length; y++) {
          var m1 = this.molecules[i].sites[y];
          if (m1.bondName != null && !names.has(m1.bondName)) {
            names.add(m1.bondName);
            var newPair = [m1.position];
            //check all sites in species for matching bond type
            for (var u = 0; u < this.molecules.length; u++) {
              for (var z = 0; z < this.molecules[u].sites.length; z++) {
                // vv to ensure a molecule doesnt bond to itself vv
                if (z != y || u != i) {
                  var m2 = this.molecules[u].sites[z];
                  if (m2.bondName == m1.bondName) {
                    newPair.push(m2.position);
                    newPair.push(m2.bondName);
                    pairs.push(newPair);
                  }
                }
              }
            }
          }
        }
      }
      //drawing bonds
      ctx.fillStyle = '#000000';
      ctx.font = "10px Arial";
      var maxHeight = 0;
      for (var i = 0; i < pairs.length; i++) {
        if (pairs[i][0][1] > maxHeight) {
          maxHeight = pairs[i][0][1];
        }
        if (pairs[i][1][1] > maxHeight) {
          maxHeight = pairs[i][1][1];
        }
        ctx.beginPath();
        ctx.moveTo(pairs[i][0][0], pairs[i][0][1]);
        //functioning code for bond labels below, omitted for style
        //ctx.fillText(pairs[i][2], pairs[i][0][0] - 7, pairs[i][0][1] + 8.5);
        ctx.lineTo(pairs[i][0][0], pairs[i][0][1] + 5 * i + 5);
        ctx.lineTo(pairs[i][1][0], pairs[i][0][1] + 5 * i + 5);
        ctx.lineTo(pairs[i][1][0], pairs[i][1][1]);
        ctx.stroke();
      }
    } else {/*canvas-unsupported code here*/}
    if (maxHeight + 10 > height + 5) {
      return ([length + 5, maxHeight + 10]);
    } else {
      return ([length + 5, height + 5]);
    }
  }
}

//displaying graphics in species
var speciesTable = document.getElementById('content-table3-species');
var rowsLen = speciesTable.rows.length;
var cellsLen = speciesTable.rows.item(1).cells.length;

for (y = 1; y < rowsLen; y++) {
  var canvasHTML = speciesTable.rows.item(y).cells.item(3).innerHTML;

  var bioNetGen = speciesTable.rows.item(y).cells.item(2).innerHTML;
  bioNetGen = bioNetGen.slice(0, bioNetGen.length - 1);
  var start = 0;

  while (canvasHTML[start] !== '""' && canvasHTML[start - 1] !== "=") {start++;}
  var index = start + 1;
  while (canvasHTML[index] !== '"') {index++;}

  HTMLiD = canvasHTML.slice(start + 1, index);
  while (bioNetGen.includes('!-')) {
    bioNetGen = bioNetGen.replace('!-', '');
  }
  while (bioNetGen.includes(',)')) {
    bioNetGen = bioNetGen.replace(',)', ')');
  }
  speciesTable.rows.item(y).cells.item(2).innerHTML = bioNetGen;
  var g = new Graphic(bioNetGen);
  dims = g.draw(HTMLiD, 0, 0);
  canvasHTML = canvasHTML.replace('width=""', 'width="' + dims[0] + '"');
  canvasHTML = canvasHTML.replace('height=""', 'height="' + dims[1] + '"');
  speciesTable.rows.item(y).cells.item(3).innerHTML = canvasHTML;
  g.draw(HTMLiD, 0, 0);
}

//displaying graphics in molecules
var moleculesTable = document.getElementById('content-table3-molecules');
var rowsLen = moleculesTable.rows.length;
var cellsLen = moleculesTable.rows.item(1).cells.length;

for (y = 1; y < rowsLen; y++) {
  var canvasHTML = moleculesTable.rows.item(y).cells.item(2).innerHTML;
  var bioNetGen = moleculesTable.rows.item(y).cells.item(1).innerHTML;
  var start = 0;

  while (canvasHTML[start] !== '""' && canvasHTML[start - 1] !== "=") {start++;}
  var index = start + 1;
  while (canvasHTML[index] !== '"') {index++;}

  HTMLiD = canvasHTML.slice(start + 1, index);
  while (bioNetGen.includes('!-')) {
    bioNetGen = bioNetGen.replace('!-', '');
  }
  while (bioNetGen.includes(',)')) {
    bioNetGen = bioNetGen.replace(',)', ')');
  }

  var m = new Molecule(bioNetGen);
  dims = m.drawComplex(HTMLiD, 0, 0);
  dims[0] += 5;
  dims[1] += 5;
  canvasHTML = canvasHTML.replace('width=""', 'width="' + dims[0] + '"');
  canvasHTML = canvasHTML.replace('height=""', 'height="' + dims[1] + '"');
  moleculesTable.rows.item(y).cells.item(2).innerHTML = canvasHTML;
  m.drawComplex(HTMLiD, 1, 1);
}


//displaying graphics in observables
var observablesTable = document.getElementById('content-table3-observables');
var rowsLen = observablesTable.rows.length;
var cellsLen = observablesTable.rows.item(1).cells.length;

for (y = 1; y < rowsLen; y++) {
  var canvasHTML = observablesTable.rows.item(y).cells.item(5).innerHTML;
  var bioNetGen = observablesTable.rows.item(y).cells.item(3).innerHTML;
  bioNetGen = bioNetGen.slice(0, bioNetGen.length - 1);
  var start = 0;

  while (canvasHTML[start] !== '""' && canvasHTML[start - 1] !== "=") {start++;}
  var index = start + 1;
  while (canvasHTML[index] !== '"') {index++;}

  HTMLiD = canvasHTML.slice(start + 1, index);
  while (bioNetGen.includes('!-')) {
    bioNetGen = bioNetGen.replace('!-', '');
  }
  while (bioNetGen.includes(',)')) {
    bioNetGen = bioNetGen.replace(',)', ')');
  }
  observablesTable.rows.item(y).cells.item(3).innerHTML = bioNetGen;

  var g = new Graphic(bioNetGen);
  dims = g.draw(HTMLiD, 0, 0);
  canvasHTML = canvasHTML.replace('width=""', 'width="' + dims[0] + '"');
  canvasHTML = canvasHTML.replace('height=""', 'height="' + dims[1] + '"');
  observablesTable.rows.item(y).cells.item(5).innerHTML = canvasHTML;
  g.draw(HTMLiD, 0, 0);
}


//displaying electrical for only membrane compartments
var table = document.getElementById('TEST');
var cells = table.rows.item(1).cells;
if (cells.item(1).innerHTML != 'Membrane'){
  cells.item(2).innerHTML = 'N/A';
}

// making the first popup visible
var firstPopup = document.querySelector(".popup").firstChild;
firstPopup.parentElement.classList.add("firstPopup");


// Open popup
var open = 1;
function reply_click(clicked_id) {
    if (open == 1) {
        $(".popup").css("opacity", 0);
        $(".overlay").css("opacity", 0);
        $(".popup").css("display", "none");
        $(".overlay").css("display", "none");
    }
    $(`.box-${clicked_id}`).css("opacity", 1);
    $(".overlay").css("opacity", 0.8);
    $(`.box-${clicked_id}`).css("display", "block");
    $(".overlay").css("display", "block");
    open = 1;
};
// close popup
$(".popup-close").click(function () {
    open = 0;
    $(".popup").css("opacity", 0);
    $(".overlay").css("opacity", 0);
    setTimeout(function () {
        $(".popup").css("display", "none");
        $(".overlay").css("display", "none");
    }, 1000);
});
